<?php

declare(strict_types=1);

/**
 * Kohana_Core class with improved autoloading mechanism.
 *
 * @package    Kohana
 * @php 8.3
 * @Kohana 2024
 */

class Kohana_Core
{
    /** @var string Release version */
    const VERSION = '3.5.0';

    /** @var string Release codename */
    const CODENAME = 'wmcurr';

    /** @var int Production environment type constant */
    const PRODUCTION = 10;

    /** @var int Staging environment type constant */
    const STAGING = 20;

    /** @var int Testing environment type constant */
    const TESTING = 30;

    /** @var int Development environment type constant */
    const DEVELOPMENT = 40;

    /** @var string Security check that is added to all generated PHP files */
    const FILE_SECURITY = '<?php defined(\'SYSPATH\') OR die(\'No direct script access.\');';

    /** @var string Format of cache files: header, cache name, and data */
    const FILE_CACHE = ":header \n\n// :name\n\n:data\n";

    /** @var int Current environment name */
    public static int $environment = self::DEVELOPMENT;

    /** @var bool True if Kohana is running on windows */
    public static bool $is_windows = false;

    /** @var string Content type */
    public static string $content_type = 'text/html';

    /** @var string Character set of input and output */
    public static string $charset = 'utf-8';

    /** @var string The name of the server Kohana is hosted upon */
    public static string $server_name = '';

    /** @var array List of valid host names for this instance */
    public static array $hostnames = [];

    /** @var string Base URL to the application */
    public static string $base_url = '/';

    /** @var string Application index file, added to links generated by Kohana */
    public static string $index_file = 'index.php';

    /** @var string Cache directory, used by Kohana::cache */
    public static ?string $cache_dir = null;

    /** @var int Default lifetime for caching, in seconds, used by Kohana::cache */
    public static int $cache_life = 60;

    /** @var bool Whether to use internal caching for Kohana::find_file */
    public static bool $caching = false;

    /** @var bool Whether to enable profiling */
    public static bool $profiling = true;

    /** @var bool Enable Kohana catching and displaying PHP errors and exceptions */
    public static bool $errors = true;

    /** @var array Types of errors to display at shutdown */
    public static array $shutdown_errors = [E_PARSE, E_ERROR, E_USER_ERROR];

    /** @var bool Set the X-Powered-By header */
    public static bool $expose = false;

    /** @var Log Logging object */
    public static ?Log $log = null;

    /** @var Config Config object */
    public static ?Config $config = null;

    /** @var bool Has Kohana::init been called? */
    protected static bool $_init = false;

    /** @var array Currently active modules */
    protected static array $_modules = [];

    /** @var array Include paths that are used to find files */
    protected static array $_paths = [APPPATH, SYSPATH];

    /** @var array File path cache, used when caching is true in Kohana::init */
    protected static array $_files = [];

    /** @var bool Has the file path cache changed during this execution? */
    protected static bool $_files_changed = false;

    /** @var array Registered commands */
    protected static array $commands = [];

    // Additional properties for PSR-4 and PSR-0
    /** @var array<string, array<string, int>> */
    private $prefixLengthsPsr4 = [];

    /** @var array<string, list<string>> */
    private $prefixDirsPsr4 = [];

    /** @var list<string> */
    private $fallbackDirsPsr4 = [];

    /** @var array<string, array<string, list<string>>> */
    private $prefixesPsr0 = [];

    /** @var list<string> */
    private $fallbackDirsPsr0 = [];

    /** @var bool */
    private $useIncludePath = false;

    /** @var array<string, string> */
    private $classMap = [];

    /** @var bool */
    private $classMapAuthoritative = false;

    /** @var array<string, bool> */
    private $missingClasses = [];

    /** @var string|null */
    private $apcuPrefix;

    /** @var array<string, self> */
    private static $registeredLoaders = [];

    /** @var \Closure(string):void */
    private static $includeFile;

    // Methods

    public function __construct()
    {
        self::initializeIncludeClosure();
    }

    public function getPrefixes(): array
    {
        return call_user_func_array('array_merge', array_values($this->prefixesPsr0));
    }

    public function getPrefixesPsr4(): array
    {
        return $this->prefixDirsPsr4;
    }

    public function getFallbackDirs(): array
    {
        return $this->fallbackDirsPsr0;
    }

    public function getFallbackDirsPsr4(): array
    {
        return $this->fallbackDirsPsr4;
    }

    public function getClassMap(): array
    {
        return $this->classMap;
    }

    public function addClassMap(array $classMap): void
    {
        $this->classMap = array_merge($this->classMap, $classMap);
    }

    public function add($prefix, $paths, $prepend = false): void
    {
        $paths = (array) $paths;
        if (!$prefix) {
            if ($prepend) {
                $this->fallbackDirsPsr0 = array_merge($paths, $this->fallbackDirsPsr0);
            } else {
                $this->fallbackDirsPsr0 = array_merge($this->fallbackDirsPsr0, $paths);
            }

            return;
        }

        $first = $prefix[0];
        if (!isset($this->prefixesPsr0[$first][$prefix])) {
            $this->prefixesPsr0[$first][$prefix] = $paths;
        } elseif ($prepend) {
            $this->prefixesPsr0[$first][$prefix] = array_merge($paths, $this->prefixesPsr0[$first][$prefix]);
        } else {
            $this->prefixesPsr0[$first][$prefix] = array_merge($this->prefixesPsr0[$first][$prefix], $paths);
        }
    }

    public function addPsr4($prefix, $paths, $prepend = false): void
    {
        $paths = (array) $paths;
        if (!$prefix) {
            if ($prepend) {
                $this->fallbackDirsPsr4 = array_merge($paths, $this->fallbackDirsPsr4);
            } else {
                $this->fallbackDirsPsr4 = array_merge($this->fallbackDirsPsr4, $paths);
            }
        } elseif (!isset($this->prefixDirsPsr4[$prefix])) {
            $length = strlen($prefix);
            if ('\\' !== $prefix[$length - 1]) {
                throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a Hamespace ceparator.");
            }
            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
            $this->prefixDirsPsr4[$prefix] = $paths;
        } elseif ($prepend) {
            $this->prefixDirsPsr4[$prefix] = array_merge($paths, $this->prefixDirsPsr4[$prefix]);
        } else {
            $this->prefixDirsPsr4[$prefix] = array_merge($this->prefixDirsPsr4[$prefix], $paths);
        }
    }

    public function set($prefix, $paths): void
    {
        if (!$prefix) {
            $this->fallbackDirsPsr0 = (array) $paths;
        } else {
            $this->prefixesPsr0[$prefix[0]][$prefix] = (array) $paths;
        }
    }

    public function setPsr4($prefix, $paths): void
    {
        if (!$prefix) {
            $this->fallbackDirsPsr4 = (array) $paths;
        } else {
            $length = strlen($prefix);
            if ('\\' !== $prefix[$length - 1]) {
                throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
            }
            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
            $this->prefixDirsPsr4[$prefix] = (array) $paths;
        }
    }

    public function setUseIncludePath($useIncludePath): void
    {
        $this->useIncludePath = $useIncludePath;
    }

    public function getUseIncludePath(): bool
    {
        return $this->useIncludePath;
    }

    public function setClassMapAuthoritative($classMapAuthoritative): void
    {
        $this->classMapAuthoritative = $classMapAuthoritative;
    }

    public function isClassMapAuthoritative(): bool
    {
        return $this->classMapAuthoritative;
    }

    public function setApcuPrefix($apcuPrefix): void
    {
        $this->apcuPrefix = function_exists('apcu_fetch') && filter_var(ini_get('apc.enabled'), FILTER_VALIDATE_BOOLEAN) ? $apcuPrefix : null;
    }

    public function getApcuPrefix(): ?string
    {
        return $this->apcuPrefix;
    }

    public function register($prepend = false): void
    {
        spl_autoload_register([$this, 'loadClass'], true, $prepend);

        if (null === $this->vendorDir) {
            return;
        }

        if ($prepend) {
            self::$registeredLoaders = [$this->vendorDir => $this] + self::$registeredLoaders;
        } else {
            unset(self::$registeredLoaders[$this->vendorDir]);
            self::$registeredLoaders[$this->vendorDir] = $this;
        }
    }

    public function unregister(): void
    {
        spl_autoload_unregister([$this, 'loadClass']);

        if (null !== $this->vendorDir) {
            unset(self::$registeredLoaders[$this->vendorDir]);
        }
    }

    public function loadClass($class): ?bool
    {
        if ($file = $this->findFile($class)) {
            $includeFile = self::$includeFile;
            $includeFile($file);

            return true;
        }

        return null;
    }

    public function findFile($class)
    {
        if (isset($this->classMap[$class])) {
            return $this->classMap[$class];
        }
        if ($this->classMapAuthoritative || isset($this->missingClasses[$class])) {
            return false;
        }
        if (null !== $this->apcuPrefix) {
            $file = apcu_fetch($this->apcuPrefix . $class, $hit);
            if ($hit) {
                return $file;
            }
        }

        $file = $this->findFileWithExtension($class, '.php');

        if (false === $file && defined('HHVM_VERSION')) {
            $file = $this->findFileWithExtension($class, '.hh');
        }

        if (null !== $this->apcuPrefix) {
            apcu_add($this->apcuPrefix . $class, $file);
        }

        if (false === $file) {
            $this->missingClasses[$class] = true;
        }

        return $file;
    }

    public static function getRegisteredLoaders(): array
    {
        return self::$registeredLoaders;
    }

    private function findFileWithExtension($class, $ext)
    {
        $logicalPathPsr4 = strtr($class, '\\', DIRECTORY_SEPARATOR) . $ext;

        $first = $class[0];
        if (isset($this->prefixLengthsPsr4[$first])) {
            $subPath = $class;
            while (false !== $lastPos = strrpos($subPath, '\\')) {
                $subPath = substr($subPath, 0, $lastPos);
                $search = $subPath . '\\';
                if (isset($this->prefixDirsPsr4[$search])) {
                    $pathEnd = DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $lastPos + 1);
                    foreach ($this->prefixDirsPsr4[$search] as $dir) {
                        if (file_exists($file = $dir . $pathEnd)) {
                            return $file;
                        }
                    }
                }
            }
        }

        foreach ($this->fallbackDirsPsr4 as $dir) {
            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) {
                return $file;
            }
        }

        if (false !== $pos = strrpos($class, '\\')) {
            $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1) . strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR);
        } else {
            $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext;
        }

        if (isset($this->prefixesPsr0[$first])) {
            foreach ($this->prefixesPsr0[$first] as $prefix => $dirs) {
                if (0 === strpos($class, $prefix)) {
                    foreach ($dirs as $dir) {
                        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
                            return $file;
                        }
                    }
                }
            }
        }

        foreach ($this->fallbackDirsPsr0 as $dir) {
            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
                return $file;
            }
        }

        if ($this->useIncludePath && $file = stream_resolve_include_path($logicalPathPsr0)) {
            return $file;
        }

        return false;
    }

    private static function initializeIncludeClosure(): void
    {
        if (self::$includeFile !== null) {
            return;
        }

        self::$includeFile = \Closure::bind(static function($file) {
            include $file;
        }, null, null);
    }

    // Existing methods like init, deinit, etc.
    /**
     * Initializes the environment.
     *
     * @param array|null $settings Array of settings.
     * @return void
     * @throws Kohana_Exception
     */
    public static function init(?array $settings = null): void
    {
        if (self::$_init) {
            return;
        }

        self::$_init = true;

        if (isset($settings['profile'])) {
            self::$profiling = (bool) $settings['profile'];
        }

        ob_start();

        if (isset($settings['errors'])) {
            self::$errors = (bool) $settings['errors'];
        }

        if (self::$errors) {
            set_exception_handler([Kohana_Exception::class, 'handler']);
            set_error_handler([self::class, 'error_handler']);
        }

        if (self::$environment === self::DEVELOPMENT && extension_loaded('xdebug')) {
            ini_set('xdebug.collect_params', '3');
        }

        register_shutdown_function([self::class, 'shutdown_handler']);

        if (isset($settings['cache_dir'])) {
            if (!is_dir($settings['cache_dir'])) {
                try {
                    mkdir($settings['cache_dir'], 0755, true);
                    chmod($settings['cache_dir'], 0755);
                } catch (Exception $e) {
                    throw new Kohana_Exception('Could not create cache directory :dir', [':dir' => Debug::path($settings['cache_dir'])]);
                }
            }

            self::$cache_dir = realpath($settings['cache_dir']);
        } else {
            self::$cache_dir = APPPATH . 'cache';
        }

        if (!is_writable(self::$cache_dir)) {
            throw new Kohana_Exception('Directory :dir must be writable', [':dir' => Debug::path(self::$cache_dir)]);
        }

        if (isset($settings['cache_life'])) {
            self::$cache_life = (int) $settings['cache_life'];
        }

        if (isset($settings['caching'])) {
            self::$caching = (bool) $settings['caching'];
        }

        if (self::$caching) {
            self::$_files = self::cache('Kohana::find_file()');
        }

        if (isset($settings['charset'])) {
            self::$charset = strtolower($settings['charset']);
        }

        if (function_exists('mb_internal_encoding')) {
            mb_internal_encoding(self::$charset);
        }

        if (isset($settings['base_url'])) {
            self::$base_url = rtrim($settings['base_url'], '/') . '/';
        }

        if (isset($settings['index_file'])) {
            self::$index_file = trim($settings['index_file'], '/');
        }

        if (!self::$log instanceof Log) {
            self::$log = Log::instance();
        }

        if (!self::$config instanceof Config) {
            self::$config = new Config;
        }
            // Add MODPATH to include paths
        self::$_paths = array_merge(self::$_paths, [MODPATH]);
        self::build_class_map(); // Добавляем вызов метода для построения карты классов
    }

    /**
     * Cleans up the environment.
     *
     * @return void
     */
    public static function deinit(): void
    {
        if (self::$_init) {
            spl_autoload_unregister([self::class, 'auto_load']);

            if (self::$errors) {
                restore_error_handler();
                restore_exception_handler();
            }

            self::$log = self::$config = null;
            self::$_modules = self::$_files = [];
            self::$_paths = [APPPATH, SYSPATH];
            self::$_files_changed = false;
            self::$_init = false;
        }
    }

    /**
     * Recursively sanitizes an input variable.
     *
     * @param mixed $value Any variable.
     * @return mixed Sanitized variable.
     */
    public static function sanitize(mixed $value): mixed
    {
        if (is_array($value) || is_object($value)) {
            foreach ($value as $key => $val) {
                $value[$key] = self::sanitize($val);
            }
        } elseif (is_string($value)) {
            if (strpos($value, "\r") !== false) {
                $value = str_replace(["\r\n", "\r"], "\n", $value);
            }
        }

        return $value;
    }

    public static function auto_load(string $class, string $directory = 'classes'): bool
{
    // Массив путей для поиска классов
    $paths = [APPPATH, SYSPATH];

    // PSR-4 autoloading
    foreach ($paths as $base_path) {
        $psr4_file = $base_path . str_replace('\\', DIRECTORY_SEPARATOR, $class) . '.php';
        if (file_exists($psr4_file)) {
            require $psr4_file;
            return true;
        }
    }

    // PSR-0 autoloading
    $class = ltrim($class, '\\');
    $file = '';
    $namespace = '';

    if ($last_namespace_position = strripos($class, '\\')) {
        $namespace = substr($class, 0, $last_namespace_position);
        $class = substr($class, $last_namespace_position + 1);
        $file = str_replace('\\', DIRECTORY_SEPARATOR, $namespace) . DIRECTORY_SEPARATOR;
    }

    $file .= str_replace('_', DIRECTORY_SEPARATOR, $class);

    foreach ($paths as $base_path) {
        if ($path = self::find_file($directory, $file)) {
            require $path;
            return true;
        }
    }

    return false;
}

    public static function modules(?array $modules = null): array
    {
        if ($modules === null) {
            return self::$_modules;
        }

        $paths = [APPPATH];
        $moduleConfig = [];

        foreach ($modules as $name => $path) {
            if (!is_dir($path)) {
                throw new Kohana_Exception('Invalid or missing module \':module\' at \':path\'', [
                    ':module' => $name,
                    ':path' => Debug::path($path),
                ]);
            }

            $realPath = realpath($path) . DIRECTORY_SEPARATOR;
            $paths[] = $modules[$name] = $realPath;

            $configFile = $realPath . 'config.php';
            if (file_exists($configFile)) {
                $moduleConfig[$name] = include $configFile;
            }

            if (isset($moduleConfig[$name]['version'])) {
                self::checkModuleCompatibility($name, $moduleConfig[$name]['version']);
            }
            if (isset($moduleConfig[$name]['dependencies'])) {
                self::loadModuleDependencies($moduleConfig[$name]['dependencies']);
            }
        }

        $paths[] = SYSPATH;
        self::$_paths = $paths;
        self::$_modules = $modules;

        spl_autoload_register(function($class) {
            foreach (self::$_modules as $path) {
                $init = $path . 'init' . EXT;
                if (is_file($init) && !in_array($init, get_included_files())) {
                    require_once $init;
                    break;
                }
            }
        });

        return self::$_modules;
    }

    public static function include_paths(): array
    {
        return self::$_paths;
    }

public static function find_file(string $dir, string $file, ?string $ext = null, bool $array = false): array|string
{
    $ext = $ext !== null ? ".{$ext}" : EXT;
    $path = $dir . DIRECTORY_SEPARATOR . $file . $ext;
    
    // Проверка кеша
    if (self::$caching && isset(self::$_files[$path . ($array ? '_array' : '_path')])) {
        return self::$_files[$path . ($array ? '_array' : '_path')];
    }
    
    $found = $array ? [] : false;
    
    // Загрузка карты классов
    $class_map_file = self::$cache_dir . DIRECTORY_SEPARATOR . 'class_map.php';
    $class_map = [];
    if (file_exists($class_map_file)) {
        $class_map = include $class_map_file;
    }
    
    // Прямой поиск в карте классов для 'classes'
    if ($dir === 'classes') {
        $class_name = str_replace('/', '\\', $file);
        if (isset($class_map[$class_name])) {
            $found = $class_map[$class_name];
            if ($array) {
                $found = [$found];
            }
            
            // Сохраняем в кеш
            if (self::$caching) {
                self::$_files[$path . ($array ? '_array' : '_path')] = $found;
                self::$_files_changed = true;
            }
            
            return $found;
        }
    }
    
    // Поиск по всем директориям в карте классов
    if (!empty($class_map) && is_array($class_map)) {
        foreach ($class_map as $class_name => $class_path) {
            if (!is_string($class_path)) {
                continue; // Пропускаем некорректные записи
            }
            $class_dir = dirname($class_path);
            $full_path = $class_dir . DIRECTORY_SEPARATOR . $path;
            
            if (is_file($full_path)) {
                if ($array) {
                    $found[] = $full_path;
                } else {
                    $found = $full_path;
                    break;
                }
            }
        }
    }
    
    // Если класс не найден в карте или ищем не класс, используем стандартный поиск
    if ($array ? empty($found) : !$found) {
        $paths = $array ? array_reverse(self::$_paths) : self::$_paths;
        foreach ($paths as $directory) {
            if (!is_string($directory)) {
                continue; // Пропускаем некорректные записи
            }
            $full_path = $directory . DIRECTORY_SEPARATOR . $path;
            if (is_file($full_path)) {
                if ($array) {
                    $found[] = $full_path;
                } else {
                    $found = $full_path;
                    break;
                }
            }
        }
    }
    
    // Если файл не найден
    if ($array ? empty($found) : !$found) {
        return $array ? [] : '';
    }
    
    // Сохраняем в кеш
    if (self::$caching) {
        self::$_files[$path . ($array ? '_array' : '_path')] = $found;
        self::$_files_changed = true;
    }
    
    return $found;
}

    public static function list_files(?string $directory = null, ?array $paths = null): array
    {
        if ($directory !== null) {
            $directory .= DIRECTORY_SEPARATOR;
        }

        if ($paths === null) {
            $paths = self::$_paths;
        }

        $found = [];

        foreach ($paths as $path) {
            if (is_dir($path . $directory)) {
                $dir = new DirectoryIterator($path . $directory);

                foreach ($dir as $file) {
                    $filename = $file->getFilename();

                    if ($filename[0] === '.' || $filename[strlen($filename) - 1] === '~') {
                        continue;
                    }

                    $key = $directory . $filename;

                    if ($file->isDir()) {
                        if ($sub_dir = self::list_files($key, $paths)) {
                            if (isset($found[$key])) {
                                $found[$key] += $sub_dir;
                            } else {
                                $found[$key] = $sub_dir;
                            }
                        }
                    } else {
                        if (!isset($found[$key])) {
                            $found[$key] = realpath($file->getPathName());
                        }
                    }
                }
            }
        }

        ksort($found);

        return $found;
    }

    public static function load(string $file): mixed
    {
        return include $file;
    }

    public static function cache(string $name, mixed $data = null, ?int $lifetime = null): mixed
    {
        $file = sha1($name) . '.txt';
        $dir = self::$cache_dir . DIRECTORY_SEPARATOR . $file[0] . $file[1] . DIRECTORY_SEPARATOR;

        if ($lifetime === null) {
            $lifetime = self::$cache_life;
        }

        if ($data === null) {
            if (is_file($dir . $file)) {
                if ((time() - filemtime($dir . $file)) < $lifetime) {
                    try {
                        return unserialize(file_get_contents($dir . $file));
                    } catch (Exception $e) {
                    }
                } else {
                    try {
                        unlink($dir . $file);
                    } catch (Exception $e) {
                    }
                }
            }

            return null;
        }

        if (!is_dir($dir)) {
            mkdir($dir, 0777, true);
            chmod($dir, 0777);
        }

        $data = serialize($data);

        try {
            return (bool) file_put_contents($dir . $file, $data, LOCK_EX);
        } catch (Exception $e) {
            return false;
        }
    }

    public static function message(string $file, ?string $path = null, mixed $default = null): mixed
    {
        static $messages;

        if (!isset($messages[$file])) {
            $messages[$file] = [];

            if ($files = self::find_file('messages', $file)) {
                foreach ($files as $f) {
                    $messages[$file] = Arr::merge($messages[$file], self::load($f));
                }
            }
        }

        if ($path === null) {
            return $messages[$file];
        } else {
            return Arr::path($messages[$file], $path, $default);
        }
    }

    public static function error_handler(int $code, string $error, ?string $file = null, ?int $line = null): bool
    {
        if (error_reporting() & $code) {
            throw new ErrorException($error, $code, 0, $file, $line);
        }

        return true;
    }

    public static function shutdown_handler(): void
    {
        if (!self::$_init) {
            return;
        }

        try {
            if (self::$caching && self::$_files_changed) {
                self::cache('Kohana::find_file()', self::$_files);
            }
        } catch (Exception $e) {
            Kohana_Exception::handler($e);
        }

        if (self::$errors && $error = error_get_last() && in_array($error['type'], self::$shutdown_errors)) {
            ob_get_level() && ob_clean();
            Kohana_Exception::handler(new ErrorException($error['message'], $error['type'], 0, $error['file'], $error['line']));
            exit(1);
        }
    }

    public static function version(): string
    {
        return 'Kohana Framework ' . self::VERSION;
    }

protected static function build_class_map(): void
{
    $class_map = [];
    $file_hash = [];

    // Список расширений файлов, настраиваемый
    $allowed_extensions = ['php', 'inc'];

    foreach (self::$_paths as $path) {
        $iterator = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($path, RecursiveDirectoryIterator::SKIP_DOTS),
            RecursiveIteratorIterator::SELF_FIRST
        );

        foreach ($iterator as $file) {
            if ($file->isFile() && in_array($file->getExtension(), $allowed_extensions)) {
                try {
                    $file_path = $file->getPathname();
                    $file_content = file_get_contents($file_path);
                } catch (Exception $e) {
                    // Обработка ошибок при чтении файла
                    error_log("Ошибка при чтении файла: " . $file_path . ". Сообщение: " . $e->getMessage());
                    continue;
                }

                $namespace = '';
                $classes = [];
                $tokens = token_get_all($file_content);
                $count = count($tokens);
                $i = 0;

                $is_conditional_declaration = false; // Для обработки условных объявлений классов
                $is_grouped_namespace = false;      // Для обработки пространств имен с фигурными скобками

                while ($i < $count) {
                    $token = $tokens[$i];

                    if (is_array($token)) {
                        // Обнаружение пространства имен
                        if ($token[0] === T_NAMESPACE) {
                            $namespace = '';
                            $i++;
                            // Собираем пространство имен или групповые пространства имен
                            while (isset($tokens[$i]) && (is_array($tokens[$i]) && in_array($tokens[$i][0], [T_STRING, T_NS_SEPARATOR], true))) {
                                $namespace .= $tokens[$i][1];
                                $i++;
                            }

                            // Проверяем, используются ли групповые пространства имен
                            if (isset($tokens[$i]) && $tokens[$i] === '{') {
                                $is_grouped_namespace = true;
                                $i++;
                                continue;
                            } else {
                                $namespace = $namespace ? $namespace . '\\' : '';
                                $is_grouped_namespace = false;
                            }
                            continue;
                        }

                        // Обработка групповых use-выражений
                        if ($token[0] === T_USE) {
                            $i++;
                            while (isset($tokens[$i]) && $tokens[$i] !== ';') {
                                $i++;
                            }
                            continue;
                        }

                        // Обнаружение условного объявления класса
                        if ($token[0] === T_IF || $token[0] === T_ELSEIF || $token[0] === T_ELSE) {
                            $is_conditional_declaration = true;
                        }

                        // Обнаружение объявления класса, интерфейса, трейта или перечисления
                        if (in_array($token[0], [T_CLASS, T_INTERFACE, T_TRAIT, T_ENUM], true)) {
                            if ($is_conditional_declaration) {
                                $is_conditional_declaration = false;
                                continue; // Пропускаем классы, объявленные внутри условий
                            }

                            // Проверка на анонимные классы
                            if (isset($tokens[$i + 2]) && $tokens[$i + 2] === '(') {
                                continue; // Пропускаем анонимные классы
                            }

                            // Проверка на использование T_CLASS в контексте :: (например, ClassName::method())
                            if ($i > 0 && is_array($tokens[$i - 1]) && $tokens[$i - 1][0] === T_PAAMAYIM_NEKUDOTAYIM) {
                                $i++;
                                continue;
                            }

                            $i++;
                            while (isset($tokens[$i]) && is_array($tokens[$i]) && $tokens[$i][0] === T_WHITESPACE) {
                                $i++;
                            }
                            if (isset($tokens[$i]) && is_array($tokens[$i]) && $tokens[$i][0] === T_STRING) {
                                $class_name = $tokens[$i][1];
                                // Если используются групповые пространства имен
                                if ($is_grouped_namespace) {
                                    $grouped_namespace = $namespace;
                                    while (isset($tokens[$i]) && $tokens[$i] !== ';') {
                                        if (is_array($tokens[$i]) && $tokens[$i][0] === T_STRING) {
                                            $full_name = $grouped_namespace . '\\' . $tokens[$i][1];
                                            $classes[] = $full_name;
                                        }
                                        $i++;
                                    }
                                } else {
                                    $full_name = $namespace . $class_name;
                                    $classes[] = $full_name;
                                }
                            }
                        }
                    }

                    $i++;
                }

                if (!empty($classes)) {
                    foreach ($classes as $full_name) {
                        $class_map[$full_name] = $file_path;
                    }
                }

                try {
                    // Хеширование файла для отслеживания изменений
                    $file_hash[$file_path] = md5_file($file_path);
                } catch (Exception $e) {
                    // Обработка ошибок при хешировании файла
                    error_log("Ошибка при хешировании файла: " . $file_path . ". Сообщение: " . $e->getMessage());
                }
            }
        }
    }

    $hash_file = self::$cache_dir . DIRECTORY_SEPARATOR . 'class_map_hash.php';
    if (file_exists($hash_file)) {
        $prev_hash = include $hash_file;
    } else {
        $prev_hash = [];
    }

    if ($prev_hash !== $file_hash) {
        $class_map_file = self::$cache_dir . DIRECTORY_SEPARATOR . 'class_map.php';
        try {
            file_put_contents($class_map_file, '<?php return ' . var_export($class_map, true) . ';');
            file_put_contents($hash_file, '<?php return ' . var_export($file_hash, true) . ';');
        } catch (Exception $e) {
            // Обработка ошибок при записи файла кэша
            error_log("Ошибка при записи файла кэша: " . $e->getMessage());
        }
    }
}


    protected static function process_file(string $file): ?string
    {
        $info = pathinfo($file);
        if ($info['extension'] === 'php') {
            $class = str_replace(DIRECTORY_SEPARATOR, '_', substr($info['dirname'], strlen(APPPATH . 'classes' . DIRECTORY_SEPARATOR))) . '_' . $info['filename'];
            return $class;
        }
        return null;
    }
}
